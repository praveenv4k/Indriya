// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: surface.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "surface.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace experimot {
namespace msgs {

namespace {

const ::google::protobuf::Descriptor* Surface_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Surface_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_surface_2eproto() {
  protobuf_AddDesc_surface_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "surface.proto");
  GOOGLE_CHECK(file != NULL);
  Surface_descriptor_ = file->message_type(0);
  static const int Surface_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, friction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, restitution_coefficient_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, bounce_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, soft_cfm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, soft_erp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, kp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, kd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, max_vel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, min_depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, collide_without_contact_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, collide_without_contact_bitmask_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, collide_bitmask_),
  };
  Surface_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Surface_descriptor_,
      Surface::default_instance_,
      Surface_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, _has_bits_[0]),
      -1,
      -1,
      sizeof(Surface),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_surface_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Surface_descriptor_, &Surface::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_surface_2eproto() {
  delete Surface::default_instance_;
  delete Surface_reflection_;
}

void protobuf_AddDesc_surface_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::experimot::msgs::protobuf_AddDesc_friction_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rsurface.proto\022\016experimot.msgs\032\016frictio"
    "n.proto\"\263\002\n\007Surface\022*\n\010friction\030\001 \001(\0132\030."
    "experimot.msgs.Friction\022\037\n\027restitution_c"
    "oefficient\030\002 \001(\001\022\030\n\020bounce_threshold\030\003 \001"
    "(\001\022\020\n\010soft_cfm\030\004 \001(\001\022\020\n\010soft_erp\030\005 \001(\001\022\n"
    "\n\002kp\030\006 \001(\001\022\n\n\002kd\030\007 \001(\001\022\017\n\007max_vel\030\010 \001(\001\022"
    "\021\n\tmin_depth\030\t \001(\001\022\037\n\027collide_without_co"
    "ntact\030\n \001(\010\022\'\n\037collide_without_contact_b"
    "itmask\030\013 \001(\r\022\027\n\017collide_bitmask\030\014 \001(\r", 357);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "surface.proto", &protobuf_RegisterTypes);
  Surface::default_instance_ = new Surface();
  Surface::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_surface_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_surface_2eproto {
  StaticDescriptorInitializer_surface_2eproto() {
    protobuf_AddDesc_surface_2eproto();
  }
} static_descriptor_initializer_surface_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int Surface::kFrictionFieldNumber;
const int Surface::kRestitutionCoefficientFieldNumber;
const int Surface::kBounceThresholdFieldNumber;
const int Surface::kSoftCfmFieldNumber;
const int Surface::kSoftErpFieldNumber;
const int Surface::kKpFieldNumber;
const int Surface::kKdFieldNumber;
const int Surface::kMaxVelFieldNumber;
const int Surface::kMinDepthFieldNumber;
const int Surface::kCollideWithoutContactFieldNumber;
const int Surface::kCollideWithoutContactBitmaskFieldNumber;
const int Surface::kCollideBitmaskFieldNumber;
#endif  // !_MSC_VER

Surface::Surface()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:experimot.msgs.Surface)
}

void Surface::InitAsDefaultInstance() {
  friction_ = const_cast< ::experimot::msgs::Friction*>(&::experimot::msgs::Friction::default_instance());
}

Surface::Surface(const Surface& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:experimot.msgs.Surface)
}

void Surface::SharedCtor() {
  _cached_size_ = 0;
  friction_ = NULL;
  restitution_coefficient_ = 0;
  bounce_threshold_ = 0;
  soft_cfm_ = 0;
  soft_erp_ = 0;
  kp_ = 0;
  kd_ = 0;
  max_vel_ = 0;
  min_depth_ = 0;
  collide_without_contact_ = false;
  collide_without_contact_bitmask_ = 0u;
  collide_bitmask_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Surface::~Surface() {
  // @@protoc_insertion_point(destructor:experimot.msgs.Surface)
  SharedDtor();
}

void Surface::SharedDtor() {
  if (this != default_instance_) {
    delete friction_;
  }
}

void Surface::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Surface::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Surface_descriptor_;
}

const Surface& Surface::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_surface_2eproto();
  return *default_instance_;
}

Surface* Surface::default_instance_ = NULL;

Surface* Surface::New(::google::protobuf::Arena* arena) const {
  Surface* n = new Surface;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Surface::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Surface*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(restitution_coefficient_, max_vel_);
    if (has_friction()) {
      if (friction_ != NULL) friction_->::experimot::msgs::Friction::Clear();
    }
  }
  ZR_(min_depth_, collide_bitmask_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Surface::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:experimot.msgs.Surface)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .experimot.msgs.Friction friction = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_friction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_restitution_coefficient;
        break;
      }

      // optional double restitution_coefficient = 2;
      case 2: {
        if (tag == 17) {
         parse_restitution_coefficient:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &restitution_coefficient_)));
          set_has_restitution_coefficient();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_bounce_threshold;
        break;
      }

      // optional double bounce_threshold = 3;
      case 3: {
        if (tag == 25) {
         parse_bounce_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &bounce_threshold_)));
          set_has_bounce_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_soft_cfm;
        break;
      }

      // optional double soft_cfm = 4;
      case 4: {
        if (tag == 33) {
         parse_soft_cfm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &soft_cfm_)));
          set_has_soft_cfm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_soft_erp;
        break;
      }

      // optional double soft_erp = 5;
      case 5: {
        if (tag == 41) {
         parse_soft_erp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &soft_erp_)));
          set_has_soft_erp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_kp;
        break;
      }

      // optional double kp = 6;
      case 6: {
        if (tag == 49) {
         parse_kp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &kp_)));
          set_has_kp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_kd;
        break;
      }

      // optional double kd = 7;
      case 7: {
        if (tag == 57) {
         parse_kd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &kd_)));
          set_has_kd();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_max_vel;
        break;
      }

      // optional double max_vel = 8;
      case 8: {
        if (tag == 65) {
         parse_max_vel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_vel_)));
          set_has_max_vel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_min_depth;
        break;
      }

      // optional double min_depth = 9;
      case 9: {
        if (tag == 73) {
         parse_min_depth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_depth_)));
          set_has_min_depth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_collide_without_contact;
        break;
      }

      // optional bool collide_without_contact = 10;
      case 10: {
        if (tag == 80) {
         parse_collide_without_contact:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &collide_without_contact_)));
          set_has_collide_without_contact();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_collide_without_contact_bitmask;
        break;
      }

      // optional uint32 collide_without_contact_bitmask = 11;
      case 11: {
        if (tag == 88) {
         parse_collide_without_contact_bitmask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &collide_without_contact_bitmask_)));
          set_has_collide_without_contact_bitmask();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_collide_bitmask;
        break;
      }

      // optional uint32 collide_bitmask = 12;
      case 12: {
        if (tag == 96) {
         parse_collide_bitmask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &collide_bitmask_)));
          set_has_collide_bitmask();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:experimot.msgs.Surface)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:experimot.msgs.Surface)
  return false;
#undef DO_
}

void Surface::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:experimot.msgs.Surface)
  // optional .experimot.msgs.Friction friction = 1;
  if (has_friction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->friction_, output);
  }

  // optional double restitution_coefficient = 2;
  if (has_restitution_coefficient()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->restitution_coefficient(), output);
  }

  // optional double bounce_threshold = 3;
  if (has_bounce_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->bounce_threshold(), output);
  }

  // optional double soft_cfm = 4;
  if (has_soft_cfm()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->soft_cfm(), output);
  }

  // optional double soft_erp = 5;
  if (has_soft_erp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->soft_erp(), output);
  }

  // optional double kp = 6;
  if (has_kp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->kp(), output);
  }

  // optional double kd = 7;
  if (has_kd()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->kd(), output);
  }

  // optional double max_vel = 8;
  if (has_max_vel()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->max_vel(), output);
  }

  // optional double min_depth = 9;
  if (has_min_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->min_depth(), output);
  }

  // optional bool collide_without_contact = 10;
  if (has_collide_without_contact()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->collide_without_contact(), output);
  }

  // optional uint32 collide_without_contact_bitmask = 11;
  if (has_collide_without_contact_bitmask()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->collide_without_contact_bitmask(), output);
  }

  // optional uint32 collide_bitmask = 12;
  if (has_collide_bitmask()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->collide_bitmask(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:experimot.msgs.Surface)
}

::google::protobuf::uint8* Surface::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:experimot.msgs.Surface)
  // optional .experimot.msgs.Friction friction = 1;
  if (has_friction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->friction_, target);
  }

  // optional double restitution_coefficient = 2;
  if (has_restitution_coefficient()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->restitution_coefficient(), target);
  }

  // optional double bounce_threshold = 3;
  if (has_bounce_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->bounce_threshold(), target);
  }

  // optional double soft_cfm = 4;
  if (has_soft_cfm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->soft_cfm(), target);
  }

  // optional double soft_erp = 5;
  if (has_soft_erp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->soft_erp(), target);
  }

  // optional double kp = 6;
  if (has_kp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->kp(), target);
  }

  // optional double kd = 7;
  if (has_kd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->kd(), target);
  }

  // optional double max_vel = 8;
  if (has_max_vel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->max_vel(), target);
  }

  // optional double min_depth = 9;
  if (has_min_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->min_depth(), target);
  }

  // optional bool collide_without_contact = 10;
  if (has_collide_without_contact()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->collide_without_contact(), target);
  }

  // optional uint32 collide_without_contact_bitmask = 11;
  if (has_collide_without_contact_bitmask()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->collide_without_contact_bitmask(), target);
  }

  // optional uint32 collide_bitmask = 12;
  if (has_collide_bitmask()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->collide_bitmask(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:experimot.msgs.Surface)
  return target;
}

int Surface::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255) {
    // optional .experimot.msgs.Friction friction = 1;
    if (has_friction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->friction_);
    }

    // optional double restitution_coefficient = 2;
    if (has_restitution_coefficient()) {
      total_size += 1 + 8;
    }

    // optional double bounce_threshold = 3;
    if (has_bounce_threshold()) {
      total_size += 1 + 8;
    }

    // optional double soft_cfm = 4;
    if (has_soft_cfm()) {
      total_size += 1 + 8;
    }

    // optional double soft_erp = 5;
    if (has_soft_erp()) {
      total_size += 1 + 8;
    }

    // optional double kp = 6;
    if (has_kp()) {
      total_size += 1 + 8;
    }

    // optional double kd = 7;
    if (has_kd()) {
      total_size += 1 + 8;
    }

    // optional double max_vel = 8;
    if (has_max_vel()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & 3840) {
    // optional double min_depth = 9;
    if (has_min_depth()) {
      total_size += 1 + 8;
    }

    // optional bool collide_without_contact = 10;
    if (has_collide_without_contact()) {
      total_size += 1 + 1;
    }

    // optional uint32 collide_without_contact_bitmask = 11;
    if (has_collide_without_contact_bitmask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->collide_without_contact_bitmask());
    }

    // optional uint32 collide_bitmask = 12;
    if (has_collide_bitmask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->collide_bitmask());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Surface::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Surface* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Surface*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Surface::MergeFrom(const Surface& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_friction()) {
      mutable_friction()->::experimot::msgs::Friction::MergeFrom(from.friction());
    }
    if (from.has_restitution_coefficient()) {
      set_restitution_coefficient(from.restitution_coefficient());
    }
    if (from.has_bounce_threshold()) {
      set_bounce_threshold(from.bounce_threshold());
    }
    if (from.has_soft_cfm()) {
      set_soft_cfm(from.soft_cfm());
    }
    if (from.has_soft_erp()) {
      set_soft_erp(from.soft_erp());
    }
    if (from.has_kp()) {
      set_kp(from.kp());
    }
    if (from.has_kd()) {
      set_kd(from.kd());
    }
    if (from.has_max_vel()) {
      set_max_vel(from.max_vel());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_min_depth()) {
      set_min_depth(from.min_depth());
    }
    if (from.has_collide_without_contact()) {
      set_collide_without_contact(from.collide_without_contact());
    }
    if (from.has_collide_without_contact_bitmask()) {
      set_collide_without_contact_bitmask(from.collide_without_contact_bitmask());
    }
    if (from.has_collide_bitmask()) {
      set_collide_bitmask(from.collide_bitmask());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Surface::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Surface::CopyFrom(const Surface& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Surface::IsInitialized() const {

  if (has_friction()) {
    if (!this->friction_->IsInitialized()) return false;
  }
  return true;
}

void Surface::Swap(Surface* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Surface::InternalSwap(Surface* other) {
  std::swap(friction_, other->friction_);
  std::swap(restitution_coefficient_, other->restitution_coefficient_);
  std::swap(bounce_threshold_, other->bounce_threshold_);
  std::swap(soft_cfm_, other->soft_cfm_);
  std::swap(soft_erp_, other->soft_erp_);
  std::swap(kp_, other->kp_);
  std::swap(kd_, other->kd_);
  std::swap(max_vel_, other->max_vel_);
  std::swap(min_depth_, other->min_depth_);
  std::swap(collide_without_contact_, other->collide_without_contact_);
  std::swap(collide_without_contact_bitmask_, other->collide_without_contact_bitmask_);
  std::swap(collide_bitmask_, other->collide_bitmask_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Surface::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Surface_descriptor_;
  metadata.reflection = Surface_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Surface

// optional .experimot.msgs.Friction friction = 1;
 bool Surface::has_friction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
 void Surface::set_has_friction() {
  _has_bits_[0] |= 0x00000001u;
}
 void Surface::clear_has_friction() {
  _has_bits_[0] &= ~0x00000001u;
}
 void Surface::clear_friction() {
  if (friction_ != NULL) friction_->::experimot::msgs::Friction::Clear();
  clear_has_friction();
}
 const ::experimot::msgs::Friction& Surface::friction() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.friction)
  return friction_ != NULL ? *friction_ : *default_instance_->friction_;
}
 ::experimot::msgs::Friction* Surface::mutable_friction() {
  set_has_friction();
  if (friction_ == NULL) {
    friction_ = new ::experimot::msgs::Friction;
  }
  // @@protoc_insertion_point(field_mutable:experimot.msgs.Surface.friction)
  return friction_;
}
 ::experimot::msgs::Friction* Surface::release_friction() {
  clear_has_friction();
  ::experimot::msgs::Friction* temp = friction_;
  friction_ = NULL;
  return temp;
}
 void Surface::set_allocated_friction(::experimot::msgs::Friction* friction) {
  delete friction_;
  friction_ = friction;
  if (friction) {
    set_has_friction();
  } else {
    clear_has_friction();
  }
  // @@protoc_insertion_point(field_set_allocated:experimot.msgs.Surface.friction)
}

// optional double restitution_coefficient = 2;
 bool Surface::has_restitution_coefficient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
 void Surface::set_has_restitution_coefficient() {
  _has_bits_[0] |= 0x00000002u;
}
 void Surface::clear_has_restitution_coefficient() {
  _has_bits_[0] &= ~0x00000002u;
}
 void Surface::clear_restitution_coefficient() {
  restitution_coefficient_ = 0;
  clear_has_restitution_coefficient();
}
 double Surface::restitution_coefficient() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.restitution_coefficient)
  return restitution_coefficient_;
}
 void Surface::set_restitution_coefficient(double value) {
  set_has_restitution_coefficient();
  restitution_coefficient_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.restitution_coefficient)
}

// optional double bounce_threshold = 3;
 bool Surface::has_bounce_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
 void Surface::set_has_bounce_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
 void Surface::clear_has_bounce_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
 void Surface::clear_bounce_threshold() {
  bounce_threshold_ = 0;
  clear_has_bounce_threshold();
}
 double Surface::bounce_threshold() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.bounce_threshold)
  return bounce_threshold_;
}
 void Surface::set_bounce_threshold(double value) {
  set_has_bounce_threshold();
  bounce_threshold_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.bounce_threshold)
}

// optional double soft_cfm = 4;
 bool Surface::has_soft_cfm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
 void Surface::set_has_soft_cfm() {
  _has_bits_[0] |= 0x00000008u;
}
 void Surface::clear_has_soft_cfm() {
  _has_bits_[0] &= ~0x00000008u;
}
 void Surface::clear_soft_cfm() {
  soft_cfm_ = 0;
  clear_has_soft_cfm();
}
 double Surface::soft_cfm() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.soft_cfm)
  return soft_cfm_;
}
 void Surface::set_soft_cfm(double value) {
  set_has_soft_cfm();
  soft_cfm_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.soft_cfm)
}

// optional double soft_erp = 5;
 bool Surface::has_soft_erp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
 void Surface::set_has_soft_erp() {
  _has_bits_[0] |= 0x00000010u;
}
 void Surface::clear_has_soft_erp() {
  _has_bits_[0] &= ~0x00000010u;
}
 void Surface::clear_soft_erp() {
  soft_erp_ = 0;
  clear_has_soft_erp();
}
 double Surface::soft_erp() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.soft_erp)
  return soft_erp_;
}
 void Surface::set_soft_erp(double value) {
  set_has_soft_erp();
  soft_erp_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.soft_erp)
}

// optional double kp = 6;
 bool Surface::has_kp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
 void Surface::set_has_kp() {
  _has_bits_[0] |= 0x00000020u;
}
 void Surface::clear_has_kp() {
  _has_bits_[0] &= ~0x00000020u;
}
 void Surface::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
 double Surface::kp() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.kp)
  return kp_;
}
 void Surface::set_kp(double value) {
  set_has_kp();
  kp_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.kp)
}

// optional double kd = 7;
 bool Surface::has_kd() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
 void Surface::set_has_kd() {
  _has_bits_[0] |= 0x00000040u;
}
 void Surface::clear_has_kd() {
  _has_bits_[0] &= ~0x00000040u;
}
 void Surface::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
 double Surface::kd() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.kd)
  return kd_;
}
 void Surface::set_kd(double value) {
  set_has_kd();
  kd_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.kd)
}

// optional double max_vel = 8;
 bool Surface::has_max_vel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
 void Surface::set_has_max_vel() {
  _has_bits_[0] |= 0x00000080u;
}
 void Surface::clear_has_max_vel() {
  _has_bits_[0] &= ~0x00000080u;
}
 void Surface::clear_max_vel() {
  max_vel_ = 0;
  clear_has_max_vel();
}
 double Surface::max_vel() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.max_vel)
  return max_vel_;
}
 void Surface::set_max_vel(double value) {
  set_has_max_vel();
  max_vel_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.max_vel)
}

// optional double min_depth = 9;
 bool Surface::has_min_depth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
 void Surface::set_has_min_depth() {
  _has_bits_[0] |= 0x00000100u;
}
 void Surface::clear_has_min_depth() {
  _has_bits_[0] &= ~0x00000100u;
}
 void Surface::clear_min_depth() {
  min_depth_ = 0;
  clear_has_min_depth();
}
 double Surface::min_depth() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.min_depth)
  return min_depth_;
}
 void Surface::set_min_depth(double value) {
  set_has_min_depth();
  min_depth_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.min_depth)
}

// optional bool collide_without_contact = 10;
 bool Surface::has_collide_without_contact() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
 void Surface::set_has_collide_without_contact() {
  _has_bits_[0] |= 0x00000200u;
}
 void Surface::clear_has_collide_without_contact() {
  _has_bits_[0] &= ~0x00000200u;
}
 void Surface::clear_collide_without_contact() {
  collide_without_contact_ = false;
  clear_has_collide_without_contact();
}
 bool Surface::collide_without_contact() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.collide_without_contact)
  return collide_without_contact_;
}
 void Surface::set_collide_without_contact(bool value) {
  set_has_collide_without_contact();
  collide_without_contact_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.collide_without_contact)
}

// optional uint32 collide_without_contact_bitmask = 11;
 bool Surface::has_collide_without_contact_bitmask() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
 void Surface::set_has_collide_without_contact_bitmask() {
  _has_bits_[0] |= 0x00000400u;
}
 void Surface::clear_has_collide_without_contact_bitmask() {
  _has_bits_[0] &= ~0x00000400u;
}
 void Surface::clear_collide_without_contact_bitmask() {
  collide_without_contact_bitmask_ = 0u;
  clear_has_collide_without_contact_bitmask();
}
 ::google::protobuf::uint32 Surface::collide_without_contact_bitmask() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.collide_without_contact_bitmask)
  return collide_without_contact_bitmask_;
}
 void Surface::set_collide_without_contact_bitmask(::google::protobuf::uint32 value) {
  set_has_collide_without_contact_bitmask();
  collide_without_contact_bitmask_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.collide_without_contact_bitmask)
}

// optional uint32 collide_bitmask = 12;
 bool Surface::has_collide_bitmask() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
 void Surface::set_has_collide_bitmask() {
  _has_bits_[0] |= 0x00000800u;
}
 void Surface::clear_has_collide_bitmask() {
  _has_bits_[0] &= ~0x00000800u;
}
 void Surface::clear_collide_bitmask() {
  collide_bitmask_ = 0u;
  clear_has_collide_bitmask();
}
 ::google::protobuf::uint32 Surface::collide_bitmask() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.Surface.collide_bitmask)
  return collide_bitmask_;
}
 void Surface::set_collide_bitmask(::google::protobuf::uint32 value) {
  set_has_collide_bitmask();
  collide_bitmask_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.Surface.collide_bitmask)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace msgs
}  // namespace experimot

EX_REGISTER_STATIC_MSG("experimot.msgs.Surface", Surface)
// @@protoc_insertion_point(global_scope)
