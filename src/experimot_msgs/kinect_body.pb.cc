// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kinect_body.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "kinect_body.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace experimot {
namespace msgs {

namespace {

const ::google::protobuf::Descriptor* KinectBody_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KinectBody_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* KinectBody_Activity_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* KinectBody_Appearance_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* KinectBody_DetectionResult_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* KinectBody_FrameEdges_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* KinectBody_Expression_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* KinectBody_TrackingConfidence_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* KinectBody_HandState_descriptor_ = NULL;
const ::google::protobuf::Descriptor* KinectBodies_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KinectBodies_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_kinect_5fbody_2eproto() {
  protobuf_AddDesc_kinect_5fbody_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "kinect_body.proto");
  GOOGLE_CHECK(file != NULL);
  KinectBody_descriptor_ = file->message_type(0);
  static const int KinectBody_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, trackingid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, istracked_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, jointcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, clippededges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, handleftconfidence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, handleftstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, handrightconfidence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, handrightstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, isrestricted_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, lean_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, leantrackingstate_),
  };
  KinectBody_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      KinectBody_descriptor_,
      KinectBody::default_instance_,
      KinectBody_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, _has_bits_[0]),
      -1,
      -1,
      sizeof(KinectBody),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBody, _internal_metadata_),
      -1);
  KinectBody_Activity_descriptor_ = KinectBody_descriptor_->enum_type(0);
  KinectBody_Appearance_descriptor_ = KinectBody_descriptor_->enum_type(1);
  KinectBody_DetectionResult_descriptor_ = KinectBody_descriptor_->enum_type(2);
  KinectBody_FrameEdges_descriptor_ = KinectBody_descriptor_->enum_type(3);
  KinectBody_Expression_descriptor_ = KinectBody_descriptor_->enum_type(4);
  KinectBody_TrackingConfidence_descriptor_ = KinectBody_descriptor_->enum_type(5);
  KinectBody_HandState_descriptor_ = KinectBody_descriptor_->enum_type(6);
  KinectBodies_descriptor_ = file->message_type(1);
  static const int KinectBodies_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBodies, body_),
  };
  KinectBodies_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      KinectBodies_descriptor_,
      KinectBodies::default_instance_,
      KinectBodies_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBodies, _has_bits_[0]),
      -1,
      -1,
      sizeof(KinectBodies),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KinectBodies, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_kinect_5fbody_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      KinectBody_descriptor_, &KinectBody::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      KinectBodies_descriptor_, &KinectBodies::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_kinect_5fbody_2eproto() {
  delete KinectBody::default_instance_;
  delete KinectBody_reflection_;
  delete KinectBodies::default_instance_;
  delete KinectBodies_reflection_;
}

void protobuf_AddDesc_kinect_5fbody_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::experimot::msgs::protobuf_AddDesc_vector2d_2eproto();
  ::experimot::msgs::protobuf_AddDesc_quaternion_2eproto();
  ::experimot::msgs::protobuf_AddDesc_kinect_5fjoint_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021kinect_body.proto\022\016experimot.msgs\032\016vec"
    "tor2d.proto\032\020quaternion.proto\032\022kinect_jo"
    "int.proto\"\310\007\n\nKinectBody\022\022\n\nTrackingId\030\001"
    " \002(\005\022\021\n\tIsTracked\030\002 \002(\010\022\022\n\nJointCount\030\003 "
    "\002(\005\022+\n\006Joints\030\004 \003(\0132\033.experimot.msgs.Kin"
    "ectJoint\022;\n\014ClippedEdges\030\005 \001(\0162%.experim"
    "ot.msgs.KinectBody.FrameEdges\022I\n\022HandLef"
    "tConfidence\030\006 \001(\0162-.experimot.msgs.Kinec"
    "tBody.TrackingConfidence\022;\n\rHandLeftStat"
    "e\030\007 \001(\0162$.experimot.msgs.KinectBody.Hand"
    "State\022J\n\023HandRightConfidence\030\010 \001(\0162-.exp"
    "erimot.msgs.KinectBody.TrackingConfidenc"
    "e\022<\n\016HandRightState\030\t \001(\0162$.experimot.ms"
    "gs.KinectBody.HandState\022\024\n\014IsRestricted\030"
    "\n \001(\010\022&\n\004Lean\030\013 \001(\0132\030.experimot.msgs.Vec"
    "tor2d\022\031\n\021LeanTrackingState\030\014 \001(\005\"a\n\010Acti"
    "vity\022\021\n\rEyeLeftClosed\020\000\022\022\n\016EyeRightClose"
    "d\020\001\022\r\n\tMouthOpen\020\002\022\016\n\nMouthMoved\020\003\022\017\n\013Lo"
    "okingAway\020\004\" \n\nAppearance\022\022\n\016WearingGlas"
    "ses\020\000\":\n\017DetectionResult\022\013\n\007Unknown\020\000\022\006\n"
    "\002No\020\001\022\t\n\005Maybe\020\002\022\007\n\003Yes\020\003\"@\n\nFrameEdges\022"
    "\010\n\004None\020\000\022\t\n\005Right\020\001\022\010\n\004Left\020\002\022\007\n\003Top\020\004\022"
    "\n\n\006Bottom\020\010\"$\n\nExpression\022\013\n\007Neutral\020\000\022\t"
    "\n\005Happy\020\001\"\'\n\022TrackingConfidence\022\007\n\003Low\020\000"
    "\022\010\n\004High\020\001\"X\n\tHandState\022\016\n\nHS_Unknown\020\000\022"
    "\021\n\rHS_NotTracked\020\001\022\013\n\007HS_Open\020\002\022\r\n\tHS_Cl"
    "osed\020\003\022\014\n\010HS_Lasso\020\004\"8\n\014KinectBodies\022(\n\004"
    "Body\030\001 \003(\0132\032.experimot.msgs.KinectBody", 1118);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "kinect_body.proto", &protobuf_RegisterTypes);
  KinectBody::default_instance_ = new KinectBody();
  KinectBodies::default_instance_ = new KinectBodies();
  KinectBody::default_instance_->InitAsDefaultInstance();
  KinectBodies::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_kinect_5fbody_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_kinect_5fbody_2eproto {
  StaticDescriptorInitializer_kinect_5fbody_2eproto() {
    protobuf_AddDesc_kinect_5fbody_2eproto();
  }
} static_descriptor_initializer_kinect_5fbody_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

const ::google::protobuf::EnumDescriptor* KinectBody_Activity_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBody_Activity_descriptor_;
}
bool KinectBody_Activity_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KinectBody_Activity KinectBody::EyeLeftClosed;
const KinectBody_Activity KinectBody::EyeRightClosed;
const KinectBody_Activity KinectBody::MouthOpen;
const KinectBody_Activity KinectBody::MouthMoved;
const KinectBody_Activity KinectBody::LookingAway;
const KinectBody_Activity KinectBody::Activity_MIN;
const KinectBody_Activity KinectBody::Activity_MAX;
const int KinectBody::Activity_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* KinectBody_Appearance_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBody_Appearance_descriptor_;
}
bool KinectBody_Appearance_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KinectBody_Appearance KinectBody::WearingGlasses;
const KinectBody_Appearance KinectBody::Appearance_MIN;
const KinectBody_Appearance KinectBody::Appearance_MAX;
const int KinectBody::Appearance_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* KinectBody_DetectionResult_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBody_DetectionResult_descriptor_;
}
bool KinectBody_DetectionResult_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KinectBody_DetectionResult KinectBody::Unknown;
const KinectBody_DetectionResult KinectBody::No;
const KinectBody_DetectionResult KinectBody::Maybe;
const KinectBody_DetectionResult KinectBody::Yes;
const KinectBody_DetectionResult KinectBody::DetectionResult_MIN;
const KinectBody_DetectionResult KinectBody::DetectionResult_MAX;
const int KinectBody::DetectionResult_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* KinectBody_FrameEdges_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBody_FrameEdges_descriptor_;
}
bool KinectBody_FrameEdges_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KinectBody_FrameEdges KinectBody::None;
const KinectBody_FrameEdges KinectBody::Right;
const KinectBody_FrameEdges KinectBody::Left;
const KinectBody_FrameEdges KinectBody::Top;
const KinectBody_FrameEdges KinectBody::Bottom;
const KinectBody_FrameEdges KinectBody::FrameEdges_MIN;
const KinectBody_FrameEdges KinectBody::FrameEdges_MAX;
const int KinectBody::FrameEdges_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* KinectBody_Expression_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBody_Expression_descriptor_;
}
bool KinectBody_Expression_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KinectBody_Expression KinectBody::Neutral;
const KinectBody_Expression KinectBody::Happy;
const KinectBody_Expression KinectBody::Expression_MIN;
const KinectBody_Expression KinectBody::Expression_MAX;
const int KinectBody::Expression_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* KinectBody_TrackingConfidence_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBody_TrackingConfidence_descriptor_;
}
bool KinectBody_TrackingConfidence_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KinectBody_TrackingConfidence KinectBody::Low;
const KinectBody_TrackingConfidence KinectBody::High;
const KinectBody_TrackingConfidence KinectBody::TrackingConfidence_MIN;
const KinectBody_TrackingConfidence KinectBody::TrackingConfidence_MAX;
const int KinectBody::TrackingConfidence_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* KinectBody_HandState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBody_HandState_descriptor_;
}
bool KinectBody_HandState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KinectBody_HandState KinectBody::HS_Unknown;
const KinectBody_HandState KinectBody::HS_NotTracked;
const KinectBody_HandState KinectBody::HS_Open;
const KinectBody_HandState KinectBody::HS_Closed;
const KinectBody_HandState KinectBody::HS_Lasso;
const KinectBody_HandState KinectBody::HandState_MIN;
const KinectBody_HandState KinectBody::HandState_MAX;
const int KinectBody::HandState_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int KinectBody::kTrackingIdFieldNumber;
const int KinectBody::kIsTrackedFieldNumber;
const int KinectBody::kJointCountFieldNumber;
const int KinectBody::kJointsFieldNumber;
const int KinectBody::kClippedEdgesFieldNumber;
const int KinectBody::kHandLeftConfidenceFieldNumber;
const int KinectBody::kHandLeftStateFieldNumber;
const int KinectBody::kHandRightConfidenceFieldNumber;
const int KinectBody::kHandRightStateFieldNumber;
const int KinectBody::kIsRestrictedFieldNumber;
const int KinectBody::kLeanFieldNumber;
const int KinectBody::kLeanTrackingStateFieldNumber;
#endif  // !_MSC_VER

KinectBody::KinectBody()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:experimot.msgs.KinectBody)
}

void KinectBody::InitAsDefaultInstance() {
  lean_ = const_cast< ::experimot::msgs::Vector2d*>(&::experimot::msgs::Vector2d::default_instance());
}

KinectBody::KinectBody(const KinectBody& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:experimot.msgs.KinectBody)
}

void KinectBody::SharedCtor() {
  _cached_size_ = 0;
  trackingid_ = 0;
  istracked_ = false;
  jointcount_ = 0;
  clippededges_ = 0;
  handleftconfidence_ = 0;
  handleftstate_ = 0;
  handrightconfidence_ = 0;
  handrightstate_ = 0;
  isrestricted_ = false;
  lean_ = NULL;
  leantrackingstate_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KinectBody::~KinectBody() {
  // @@protoc_insertion_point(destructor:experimot.msgs.KinectBody)
  SharedDtor();
}

void KinectBody::SharedDtor() {
  if (this != default_instance_) {
    delete lean_;
  }
}

void KinectBody::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KinectBody::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBody_descriptor_;
}

const KinectBody& KinectBody::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kinect_5fbody_2eproto();
  return *default_instance_;
}

KinectBody* KinectBody::default_instance_ = NULL;

KinectBody* KinectBody::New(::google::protobuf::Arena* arena) const {
  KinectBody* n = new KinectBody;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KinectBody::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<KinectBody*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 247) {
    ZR_(trackingid_, jointcount_);
    ZR_(clippededges_, istracked_);
    ZR_(handleftstate_, handrightconfidence_);
  }
  if (_has_bits_[8 / 32] & 3840) {
    handrightstate_ = 0;
    isrestricted_ = false;
    if (has_lean()) {
      if (lean_ != NULL) lean_->::experimot::msgs::Vector2d::Clear();
    }
    leantrackingstate_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  joints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool KinectBody::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:experimot.msgs.KinectBody)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 TrackingId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &trackingid_)));
          set_has_trackingid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_IsTracked;
        break;
      }

      // required bool IsTracked = 2;
      case 2: {
        if (tag == 16) {
         parse_IsTracked:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &istracked_)));
          set_has_istracked();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_JointCount;
        break;
      }

      // required int32 JointCount = 3;
      case 3: {
        if (tag == 24) {
         parse_JointCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &jointcount_)));
          set_has_jointcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Joints;
        break;
      }

      // repeated .experimot.msgs.KinectJoint Joints = 4;
      case 4: {
        if (tag == 34) {
         parse_Joints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Joints;
        if (input->ExpectTag(40)) goto parse_ClippedEdges;
        break;
      }

      // optional .experimot.msgs.KinectBody.FrameEdges ClippedEdges = 5;
      case 5: {
        if (tag == 40) {
         parse_ClippedEdges:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::experimot::msgs::KinectBody_FrameEdges_IsValid(value)) {
            set_clippededges(static_cast< ::experimot::msgs::KinectBody_FrameEdges >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_HandLeftConfidence;
        break;
      }

      // optional .experimot.msgs.KinectBody.TrackingConfidence HandLeftConfidence = 6;
      case 6: {
        if (tag == 48) {
         parse_HandLeftConfidence:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::experimot::msgs::KinectBody_TrackingConfidence_IsValid(value)) {
            set_handleftconfidence(static_cast< ::experimot::msgs::KinectBody_TrackingConfidence >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_HandLeftState;
        break;
      }

      // optional .experimot.msgs.KinectBody.HandState HandLeftState = 7;
      case 7: {
        if (tag == 56) {
         parse_HandLeftState:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::experimot::msgs::KinectBody_HandState_IsValid(value)) {
            set_handleftstate(static_cast< ::experimot::msgs::KinectBody_HandState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_HandRightConfidence;
        break;
      }

      // optional .experimot.msgs.KinectBody.TrackingConfidence HandRightConfidence = 8;
      case 8: {
        if (tag == 64) {
         parse_HandRightConfidence:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::experimot::msgs::KinectBody_TrackingConfidence_IsValid(value)) {
            set_handrightconfidence(static_cast< ::experimot::msgs::KinectBody_TrackingConfidence >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_HandRightState;
        break;
      }

      // optional .experimot.msgs.KinectBody.HandState HandRightState = 9;
      case 9: {
        if (tag == 72) {
         parse_HandRightState:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::experimot::msgs::KinectBody_HandState_IsValid(value)) {
            set_handrightstate(static_cast< ::experimot::msgs::KinectBody_HandState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_IsRestricted;
        break;
      }

      // optional bool IsRestricted = 10;
      case 10: {
        if (tag == 80) {
         parse_IsRestricted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isrestricted_)));
          set_has_isrestricted();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_Lean;
        break;
      }

      // optional .experimot.msgs.Vector2d Lean = 11;
      case 11: {
        if (tag == 90) {
         parse_Lean:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lean()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_LeanTrackingState;
        break;
      }

      // optional int32 LeanTrackingState = 12;
      case 12: {
        if (tag == 96) {
         parse_LeanTrackingState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &leantrackingstate_)));
          set_has_leantrackingstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:experimot.msgs.KinectBody)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:experimot.msgs.KinectBody)
  return false;
#undef DO_
}

void KinectBody::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:experimot.msgs.KinectBody)
  // required int32 TrackingId = 1;
  if (has_trackingid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->trackingid(), output);
  }

  // required bool IsTracked = 2;
  if (has_istracked()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->istracked(), output);
  }

  // required int32 JointCount = 3;
  if (has_jointcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->jointcount(), output);
  }

  // repeated .experimot.msgs.KinectJoint Joints = 4;
  for (unsigned int i = 0, n = this->joints_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->joints(i), output);
  }

  // optional .experimot.msgs.KinectBody.FrameEdges ClippedEdges = 5;
  if (has_clippededges()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->clippededges(), output);
  }

  // optional .experimot.msgs.KinectBody.TrackingConfidence HandLeftConfidence = 6;
  if (has_handleftconfidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->handleftconfidence(), output);
  }

  // optional .experimot.msgs.KinectBody.HandState HandLeftState = 7;
  if (has_handleftstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->handleftstate(), output);
  }

  // optional .experimot.msgs.KinectBody.TrackingConfidence HandRightConfidence = 8;
  if (has_handrightconfidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->handrightconfidence(), output);
  }

  // optional .experimot.msgs.KinectBody.HandState HandRightState = 9;
  if (has_handrightstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->handrightstate(), output);
  }

  // optional bool IsRestricted = 10;
  if (has_isrestricted()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->isrestricted(), output);
  }

  // optional .experimot.msgs.Vector2d Lean = 11;
  if (has_lean()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->lean_, output);
  }

  // optional int32 LeanTrackingState = 12;
  if (has_leantrackingstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->leantrackingstate(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:experimot.msgs.KinectBody)
}

::google::protobuf::uint8* KinectBody::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:experimot.msgs.KinectBody)
  // required int32 TrackingId = 1;
  if (has_trackingid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->trackingid(), target);
  }

  // required bool IsTracked = 2;
  if (has_istracked()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->istracked(), target);
  }

  // required int32 JointCount = 3;
  if (has_jointcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->jointcount(), target);
  }

  // repeated .experimot.msgs.KinectJoint Joints = 4;
  for (unsigned int i = 0, n = this->joints_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->joints(i), target);
  }

  // optional .experimot.msgs.KinectBody.FrameEdges ClippedEdges = 5;
  if (has_clippededges()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->clippededges(), target);
  }

  // optional .experimot.msgs.KinectBody.TrackingConfidence HandLeftConfidence = 6;
  if (has_handleftconfidence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->handleftconfidence(), target);
  }

  // optional .experimot.msgs.KinectBody.HandState HandLeftState = 7;
  if (has_handleftstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->handleftstate(), target);
  }

  // optional .experimot.msgs.KinectBody.TrackingConfidence HandRightConfidence = 8;
  if (has_handrightconfidence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->handrightconfidence(), target);
  }

  // optional .experimot.msgs.KinectBody.HandState HandRightState = 9;
  if (has_handrightstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->handrightstate(), target);
  }

  // optional bool IsRestricted = 10;
  if (has_isrestricted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->isrestricted(), target);
  }

  // optional .experimot.msgs.Vector2d Lean = 11;
  if (has_lean()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, *this->lean_, target);
  }

  // optional int32 LeanTrackingState = 12;
  if (has_leantrackingstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->leantrackingstate(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:experimot.msgs.KinectBody)
  return target;
}

int KinectBody::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_trackingid()) {
    // required int32 TrackingId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->trackingid());
  }

  if (has_istracked()) {
    // required bool IsTracked = 2;
    total_size += 1 + 1;
  }

  if (has_jointcount()) {
    // required int32 JointCount = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->jointcount());
  }

  return total_size;
}
int KinectBody::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 TrackingId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->trackingid());

    // required bool IsTracked = 2;
    total_size += 1 + 1;

    // required int32 JointCount = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->jointcount());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[4 / 32] & 240) {
    // optional .experimot.msgs.KinectBody.FrameEdges ClippedEdges = 5;
    if (has_clippededges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->clippededges());
    }

    // optional .experimot.msgs.KinectBody.TrackingConfidence HandLeftConfidence = 6;
    if (has_handleftconfidence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->handleftconfidence());
    }

    // optional .experimot.msgs.KinectBody.HandState HandLeftState = 7;
    if (has_handleftstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->handleftstate());
    }

    // optional .experimot.msgs.KinectBody.TrackingConfidence HandRightConfidence = 8;
    if (has_handrightconfidence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->handrightconfidence());
    }

  }
  if (_has_bits_[8 / 32] & 3840) {
    // optional .experimot.msgs.KinectBody.HandState HandRightState = 9;
    if (has_handrightstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->handrightstate());
    }

    // optional bool IsRestricted = 10;
    if (has_isrestricted()) {
      total_size += 1 + 1;
    }

    // optional .experimot.msgs.Vector2d Lean = 11;
    if (has_lean()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lean_);
    }

    // optional int32 LeanTrackingState = 12;
    if (has_leantrackingstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->leantrackingstate());
    }

  }
  // repeated .experimot.msgs.KinectJoint Joints = 4;
  total_size += 1 * this->joints_size();
  for (int i = 0; i < this->joints_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->joints(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KinectBody::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const KinectBody* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KinectBody*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KinectBody::MergeFrom(const KinectBody& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  joints_.MergeFrom(from.joints_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trackingid()) {
      set_trackingid(from.trackingid());
    }
    if (from.has_istracked()) {
      set_istracked(from.istracked());
    }
    if (from.has_jointcount()) {
      set_jointcount(from.jointcount());
    }
    if (from.has_clippededges()) {
      set_clippededges(from.clippededges());
    }
    if (from.has_handleftconfidence()) {
      set_handleftconfidence(from.handleftconfidence());
    }
    if (from.has_handleftstate()) {
      set_handleftstate(from.handleftstate());
    }
    if (from.has_handrightconfidence()) {
      set_handrightconfidence(from.handrightconfidence());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_handrightstate()) {
      set_handrightstate(from.handrightstate());
    }
    if (from.has_isrestricted()) {
      set_isrestricted(from.isrestricted());
    }
    if (from.has_lean()) {
      mutable_lean()->::experimot::msgs::Vector2d::MergeFrom(from.lean());
    }
    if (from.has_leantrackingstate()) {
      set_leantrackingstate(from.leantrackingstate());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void KinectBody::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KinectBody::CopyFrom(const KinectBody& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KinectBody::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->joints())) return false;
  if (has_lean()) {
    if (!this->lean_->IsInitialized()) return false;
  }
  return true;
}

void KinectBody::Swap(KinectBody* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KinectBody::InternalSwap(KinectBody* other) {
  std::swap(trackingid_, other->trackingid_);
  std::swap(istracked_, other->istracked_);
  std::swap(jointcount_, other->jointcount_);
  joints_.UnsafeArenaSwap(&other->joints_);
  std::swap(clippededges_, other->clippededges_);
  std::swap(handleftconfidence_, other->handleftconfidence_);
  std::swap(handleftstate_, other->handleftstate_);
  std::swap(handrightconfidence_, other->handrightconfidence_);
  std::swap(handrightstate_, other->handrightstate_);
  std::swap(isrestricted_, other->isrestricted_);
  std::swap(lean_, other->lean_);
  std::swap(leantrackingstate_, other->leantrackingstate_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata KinectBody::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KinectBody_descriptor_;
  metadata.reflection = KinectBody_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KinectBody

// required int32 TrackingId = 1;
 bool KinectBody::has_trackingid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
 void KinectBody::set_has_trackingid() {
  _has_bits_[0] |= 0x00000001u;
}
 void KinectBody::clear_has_trackingid() {
  _has_bits_[0] &= ~0x00000001u;
}
 void KinectBody::clear_trackingid() {
  trackingid_ = 0;
  clear_has_trackingid();
}
 ::google::protobuf::int32 KinectBody::trackingid() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.TrackingId)
  return trackingid_;
}
 void KinectBody::set_trackingid(::google::protobuf::int32 value) {
  set_has_trackingid();
  trackingid_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.TrackingId)
}

// required bool IsTracked = 2;
 bool KinectBody::has_istracked() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
 void KinectBody::set_has_istracked() {
  _has_bits_[0] |= 0x00000002u;
}
 void KinectBody::clear_has_istracked() {
  _has_bits_[0] &= ~0x00000002u;
}
 void KinectBody::clear_istracked() {
  istracked_ = false;
  clear_has_istracked();
}
 bool KinectBody::istracked() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.IsTracked)
  return istracked_;
}
 void KinectBody::set_istracked(bool value) {
  set_has_istracked();
  istracked_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.IsTracked)
}

// required int32 JointCount = 3;
 bool KinectBody::has_jointcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
 void KinectBody::set_has_jointcount() {
  _has_bits_[0] |= 0x00000004u;
}
 void KinectBody::clear_has_jointcount() {
  _has_bits_[0] &= ~0x00000004u;
}
 void KinectBody::clear_jointcount() {
  jointcount_ = 0;
  clear_has_jointcount();
}
 ::google::protobuf::int32 KinectBody::jointcount() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.JointCount)
  return jointcount_;
}
 void KinectBody::set_jointcount(::google::protobuf::int32 value) {
  set_has_jointcount();
  jointcount_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.JointCount)
}

// repeated .experimot.msgs.KinectJoint Joints = 4;
 int KinectBody::joints_size() const {
  return joints_.size();
}
 void KinectBody::clear_joints() {
  joints_.Clear();
}
 const ::experimot::msgs::KinectJoint& KinectBody::joints(int index) const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.Joints)
  return joints_.Get(index);
}
 ::experimot::msgs::KinectJoint* KinectBody::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:experimot.msgs.KinectBody.Joints)
  return joints_.Mutable(index);
}
 ::experimot::msgs::KinectJoint* KinectBody::add_joints() {
  // @@protoc_insertion_point(field_add:experimot.msgs.KinectBody.Joints)
  return joints_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::experimot::msgs::KinectJoint >&
KinectBody::joints() const {
  // @@protoc_insertion_point(field_list:experimot.msgs.KinectBody.Joints)
  return joints_;
}
 ::google::protobuf::RepeatedPtrField< ::experimot::msgs::KinectJoint >*
KinectBody::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:experimot.msgs.KinectBody.Joints)
  return &joints_;
}

// optional .experimot.msgs.KinectBody.FrameEdges ClippedEdges = 5;
 bool KinectBody::has_clippededges() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
 void KinectBody::set_has_clippededges() {
  _has_bits_[0] |= 0x00000010u;
}
 void KinectBody::clear_has_clippededges() {
  _has_bits_[0] &= ~0x00000010u;
}
 void KinectBody::clear_clippededges() {
  clippededges_ = 0;
  clear_has_clippededges();
}
 ::experimot::msgs::KinectBody_FrameEdges KinectBody::clippededges() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.ClippedEdges)
  return static_cast< ::experimot::msgs::KinectBody_FrameEdges >(clippededges_);
}
 void KinectBody::set_clippededges(::experimot::msgs::KinectBody_FrameEdges value) {
  assert(::experimot::msgs::KinectBody_FrameEdges_IsValid(value));
  set_has_clippededges();
  clippededges_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.ClippedEdges)
}

// optional .experimot.msgs.KinectBody.TrackingConfidence HandLeftConfidence = 6;
 bool KinectBody::has_handleftconfidence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
 void KinectBody::set_has_handleftconfidence() {
  _has_bits_[0] |= 0x00000020u;
}
 void KinectBody::clear_has_handleftconfidence() {
  _has_bits_[0] &= ~0x00000020u;
}
 void KinectBody::clear_handleftconfidence() {
  handleftconfidence_ = 0;
  clear_has_handleftconfidence();
}
 ::experimot::msgs::KinectBody_TrackingConfidence KinectBody::handleftconfidence() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.HandLeftConfidence)
  return static_cast< ::experimot::msgs::KinectBody_TrackingConfidence >(handleftconfidence_);
}
 void KinectBody::set_handleftconfidence(::experimot::msgs::KinectBody_TrackingConfidence value) {
  assert(::experimot::msgs::KinectBody_TrackingConfidence_IsValid(value));
  set_has_handleftconfidence();
  handleftconfidence_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.HandLeftConfidence)
}

// optional .experimot.msgs.KinectBody.HandState HandLeftState = 7;
 bool KinectBody::has_handleftstate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
 void KinectBody::set_has_handleftstate() {
  _has_bits_[0] |= 0x00000040u;
}
 void KinectBody::clear_has_handleftstate() {
  _has_bits_[0] &= ~0x00000040u;
}
 void KinectBody::clear_handleftstate() {
  handleftstate_ = 0;
  clear_has_handleftstate();
}
 ::experimot::msgs::KinectBody_HandState KinectBody::handleftstate() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.HandLeftState)
  return static_cast< ::experimot::msgs::KinectBody_HandState >(handleftstate_);
}
 void KinectBody::set_handleftstate(::experimot::msgs::KinectBody_HandState value) {
  assert(::experimot::msgs::KinectBody_HandState_IsValid(value));
  set_has_handleftstate();
  handleftstate_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.HandLeftState)
}

// optional .experimot.msgs.KinectBody.TrackingConfidence HandRightConfidence = 8;
 bool KinectBody::has_handrightconfidence() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
 void KinectBody::set_has_handrightconfidence() {
  _has_bits_[0] |= 0x00000080u;
}
 void KinectBody::clear_has_handrightconfidence() {
  _has_bits_[0] &= ~0x00000080u;
}
 void KinectBody::clear_handrightconfidence() {
  handrightconfidence_ = 0;
  clear_has_handrightconfidence();
}
 ::experimot::msgs::KinectBody_TrackingConfidence KinectBody::handrightconfidence() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.HandRightConfidence)
  return static_cast< ::experimot::msgs::KinectBody_TrackingConfidence >(handrightconfidence_);
}
 void KinectBody::set_handrightconfidence(::experimot::msgs::KinectBody_TrackingConfidence value) {
  assert(::experimot::msgs::KinectBody_TrackingConfidence_IsValid(value));
  set_has_handrightconfidence();
  handrightconfidence_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.HandRightConfidence)
}

// optional .experimot.msgs.KinectBody.HandState HandRightState = 9;
 bool KinectBody::has_handrightstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
 void KinectBody::set_has_handrightstate() {
  _has_bits_[0] |= 0x00000100u;
}
 void KinectBody::clear_has_handrightstate() {
  _has_bits_[0] &= ~0x00000100u;
}
 void KinectBody::clear_handrightstate() {
  handrightstate_ = 0;
  clear_has_handrightstate();
}
 ::experimot::msgs::KinectBody_HandState KinectBody::handrightstate() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.HandRightState)
  return static_cast< ::experimot::msgs::KinectBody_HandState >(handrightstate_);
}
 void KinectBody::set_handrightstate(::experimot::msgs::KinectBody_HandState value) {
  assert(::experimot::msgs::KinectBody_HandState_IsValid(value));
  set_has_handrightstate();
  handrightstate_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.HandRightState)
}

// optional bool IsRestricted = 10;
 bool KinectBody::has_isrestricted() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
 void KinectBody::set_has_isrestricted() {
  _has_bits_[0] |= 0x00000200u;
}
 void KinectBody::clear_has_isrestricted() {
  _has_bits_[0] &= ~0x00000200u;
}
 void KinectBody::clear_isrestricted() {
  isrestricted_ = false;
  clear_has_isrestricted();
}
 bool KinectBody::isrestricted() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.IsRestricted)
  return isrestricted_;
}
 void KinectBody::set_isrestricted(bool value) {
  set_has_isrestricted();
  isrestricted_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.IsRestricted)
}

// optional .experimot.msgs.Vector2d Lean = 11;
 bool KinectBody::has_lean() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
 void KinectBody::set_has_lean() {
  _has_bits_[0] |= 0x00000400u;
}
 void KinectBody::clear_has_lean() {
  _has_bits_[0] &= ~0x00000400u;
}
 void KinectBody::clear_lean() {
  if (lean_ != NULL) lean_->::experimot::msgs::Vector2d::Clear();
  clear_has_lean();
}
 const ::experimot::msgs::Vector2d& KinectBody::lean() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.Lean)
  return lean_ != NULL ? *lean_ : *default_instance_->lean_;
}
 ::experimot::msgs::Vector2d* KinectBody::mutable_lean() {
  set_has_lean();
  if (lean_ == NULL) {
    lean_ = new ::experimot::msgs::Vector2d;
  }
  // @@protoc_insertion_point(field_mutable:experimot.msgs.KinectBody.Lean)
  return lean_;
}
 ::experimot::msgs::Vector2d* KinectBody::release_lean() {
  clear_has_lean();
  ::experimot::msgs::Vector2d* temp = lean_;
  lean_ = NULL;
  return temp;
}
 void KinectBody::set_allocated_lean(::experimot::msgs::Vector2d* lean) {
  delete lean_;
  lean_ = lean;
  if (lean) {
    set_has_lean();
  } else {
    clear_has_lean();
  }
  // @@protoc_insertion_point(field_set_allocated:experimot.msgs.KinectBody.Lean)
}

// optional int32 LeanTrackingState = 12;
 bool KinectBody::has_leantrackingstate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
 void KinectBody::set_has_leantrackingstate() {
  _has_bits_[0] |= 0x00000800u;
}
 void KinectBody::clear_has_leantrackingstate() {
  _has_bits_[0] &= ~0x00000800u;
}
 void KinectBody::clear_leantrackingstate() {
  leantrackingstate_ = 0;
  clear_has_leantrackingstate();
}
 ::google::protobuf::int32 KinectBody::leantrackingstate() const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBody.LeanTrackingState)
  return leantrackingstate_;
}
 void KinectBody::set_leantrackingstate(::google::protobuf::int32 value) {
  set_has_leantrackingstate();
  leantrackingstate_ = value;
  // @@protoc_insertion_point(field_set:experimot.msgs.KinectBody.LeanTrackingState)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int KinectBodies::kBodyFieldNumber;
#endif  // !_MSC_VER

KinectBodies::KinectBodies()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:experimot.msgs.KinectBodies)
}

void KinectBodies::InitAsDefaultInstance() {
}

KinectBodies::KinectBodies(const KinectBodies& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:experimot.msgs.KinectBodies)
}

void KinectBodies::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KinectBodies::~KinectBodies() {
  // @@protoc_insertion_point(destructor:experimot.msgs.KinectBodies)
  SharedDtor();
}

void KinectBodies::SharedDtor() {
  if (this != default_instance_) {
  }
}

void KinectBodies::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KinectBodies::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KinectBodies_descriptor_;
}

const KinectBodies& KinectBodies::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kinect_5fbody_2eproto();
  return *default_instance_;
}

KinectBodies* KinectBodies::default_instance_ = NULL;

KinectBodies* KinectBodies::New(::google::protobuf::Arena* arena) const {
  KinectBodies* n = new KinectBodies;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KinectBodies::Clear() {
  body_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool KinectBodies::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:experimot.msgs.KinectBodies)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .experimot.msgs.KinectBody Body = 1;
      case 1: {
        if (tag == 10) {
         parse_Body:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_body()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_Body;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:experimot.msgs.KinectBodies)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:experimot.msgs.KinectBodies)
  return false;
#undef DO_
}

void KinectBodies::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:experimot.msgs.KinectBodies)
  // repeated .experimot.msgs.KinectBody Body = 1;
  for (unsigned int i = 0, n = this->body_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->body(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:experimot.msgs.KinectBodies)
}

::google::protobuf::uint8* KinectBodies::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:experimot.msgs.KinectBodies)
  // repeated .experimot.msgs.KinectBody Body = 1;
  for (unsigned int i = 0, n = this->body_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->body(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:experimot.msgs.KinectBodies)
  return target;
}

int KinectBodies::ByteSize() const {
  int total_size = 0;

  // repeated .experimot.msgs.KinectBody Body = 1;
  total_size += 1 * this->body_size();
  for (int i = 0; i < this->body_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->body(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KinectBodies::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const KinectBodies* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KinectBodies*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KinectBodies::MergeFrom(const KinectBodies& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  body_.MergeFrom(from.body_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void KinectBodies::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KinectBodies::CopyFrom(const KinectBodies& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KinectBodies::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->body())) return false;
  return true;
}

void KinectBodies::Swap(KinectBodies* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KinectBodies::InternalSwap(KinectBodies* other) {
  body_.UnsafeArenaSwap(&other->body_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata KinectBodies::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KinectBodies_descriptor_;
  metadata.reflection = KinectBodies_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KinectBodies

// repeated .experimot.msgs.KinectBody Body = 1;
 int KinectBodies::body_size() const {
  return body_.size();
}
 void KinectBodies::clear_body() {
  body_.Clear();
}
 const ::experimot::msgs::KinectBody& KinectBodies::body(int index) const {
  // @@protoc_insertion_point(field_get:experimot.msgs.KinectBodies.Body)
  return body_.Get(index);
}
 ::experimot::msgs::KinectBody* KinectBodies::mutable_body(int index) {
  // @@protoc_insertion_point(field_mutable:experimot.msgs.KinectBodies.Body)
  return body_.Mutable(index);
}
 ::experimot::msgs::KinectBody* KinectBodies::add_body() {
  // @@protoc_insertion_point(field_add:experimot.msgs.KinectBodies.Body)
  return body_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::experimot::msgs::KinectBody >&
KinectBodies::body() const {
  // @@protoc_insertion_point(field_list:experimot.msgs.KinectBodies.Body)
  return body_;
}
 ::google::protobuf::RepeatedPtrField< ::experimot::msgs::KinectBody >*
KinectBodies::mutable_body() {
  // @@protoc_insertion_point(field_mutable_list:experimot.msgs.KinectBodies.Body)
  return &body_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace msgs
}  // namespace experimot

EX_REGISTER_STATIC_MSG("experimot.msgs.KinectBody", KinectBody)
// @@protoc_insertion_point(global_scope)
